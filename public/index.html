<!doctype html>
<html lang="ko" data-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Midnight Love Letter</title>
  <link
    rel="stylesheet"
    href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"
  />
  <style>
    main { padding-block: 1.5rem; }
    .form-grid { display: grid; gap: 0.75rem; align-items: end; }
    .pill-row { display: flex; gap: 0.5rem; flex-wrap: wrap; flex-direction: column; }
    pre { max-height: 240px; overflow: auto; }
    .hidden { display: none !important; }
    .space-top { margin-top: 0.5rem; }
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: grid;
      place-items: center;
      padding: 1rem;
      z-index: 10;
    }
    .modal-card {
      background: var(--pico-card-background-color);
      color: var(--pico-color);
      max-width: 640px;
      max-height: min(90vh, 100%);
      width: min(640px, 100%);
      padding: 1.25rem;
      border-radius: 0.75rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      overflow: auto; /* allow scrolling when content is tall */
    }
    .modal-card h4 { margin-top: 0; }
    #consoleLog { max-height: 320px; min-height: 160px; }
  </style>
</head>
<body>
  <main class="container">
    <header>
      <hgroup>
        <h1>Midnight Love Letter</h1>
      </hgroup>
    </header>

    <article id="lobby">
      <h3>대기실</h3>
      <div class="form-grid">
        <label>방 코드 <input id="roomId" placeholder="lobby-1" /></label>
        <label>이름 <input id="name" placeholder="플레이어" /></label>
        <button id="join" class="secondary">입장</button>
        <button id="start" class="contrast">게임 시작</button>
      </div>
    </article>

    <article id="console" data-requires-room>
      <h3>로그</h3>
      <pre id="consoleLog" aria-live="polite"></pre>
    </article>

    <article data-requires-room>
      <h3>플레이어</h3>
      <div id="players" class="pill-row"></div>
    </article>

    <article data-requires-room data-requires-start>
      <h3>행동</h3>
      <div class="form-grid">
        <section>
          <div id="hand" class="pill-row space-top"></div>
        </section>
        <section>
          <div id="requirements" class="pill-row space-top"></div>
          <button id="playAction" class="contrast space-top">실행</button>
          <small id="actionHint"></small>
        </section>
      </div>
    </article>

    <article data-requires-room data-requires-start>
      <h3>테이블</h3>
      <span id="deckInfo"></span>
      <div id="discard" class="pill-row"></div>
    </article>

    <article data-requires-room data-requires-start>
      <h3>디버그 상태</h3>
      <pre id="state"></pre>
    </article>

    <section class="space-top">
      <button id="showRules" class="secondary">룰 및 기타 정보</button>
    </section>

    <div id="rulesModal" class="modal-backdrop hidden" role="dialog" aria-modal="true">
      <article class="modal-card">
        <header>
          <h4>미드나이트 러브레터</h4>
        </header>
        <h4>카드 효과</h4>
        <ul>
          <li>1. 경비병: 플레이어를 한 명 지목해서 경비병 카드 외에 상대가 가진 카드를 추측하여 선언한다. 만약 맞췄을 경우 지목된 플레이어는 탈락한다.</li>
          <li>2. 사제: 플레이어 한 명을 지목해서 그 플레이어가 손에 들고 있는 카드를 확인한다.</li>
          <li>3. 남작: 플레이어 한 명을 지목해서 자신의 손에 남아있는 카드와 상대가 들고 있는 카드를 비교한다. 이때 더 낮은 숫자를 가진 플레이어는 탈락한다.</li>
          <li>4. 시녀: 다음 차례가 올 때까지 다른 카드의 영향을 받지 않는다.</li>
          <li>5. 왕자: 자신, 혹은 다른 플레이어 중 한 명을 지목해서 카드를 버리고 다시 뽑게 한다. 공주를 제외한 카드 효과는 발동하지 않는다.</li>
          <li>6. 왕: 플레이어 중 한 명을 지목하여 손에 든 카드를 서로 교환한다.</li>
          <li>7. 백작부인: 왕자 혹은 왕 카드와 함께 들고 있는 경우 반드시 이 카드를 버려야 한다. 아닐 경우에는 선택적으로 버릴 수 있다.</li>
          <li>8. 공주: 버리면 탈락한다.</li>
        </ul>
        <h4>스토리</h4>
        <p>마리아나 왕비가 대역죄로 구금 당하게 된 사건으로 인해서 왕비의 딸인 아네트 공주보다 비통해하는 사람은 없을 것입니다.</p>
        <p>이와 같은 상황에서 도시국가인 템페스트의 도처에서 아네트 공주의 슬픔을 사랑으로 덜어주고자 하는 청혼자들이 몰려들었습니다.</p>
        <p>여러분들은 바로 이 청혼자들 중 한명이 되어 아네트 공주에게 편지를 전하고자 하게 됩니다.</p>
        <p>하지만 안타깝게도, 공주는 자신의 처소에서 도무지 나오려 하지 않기에 궁궐에 있는 사람들에게 편지를 전달해 주기를 부탁할 수밖에 없습니다.</p>
        <p>여러분들은 몰래 카드 한 장을 손에 가지고 게임을 진행해 나갑니다.</p>
        <p>이 카드가 바로 아네트 공주를 향한 당신의 사랑이 담긴 편지를 전달해 줄 사람입니다.</p>
        <p>하루가 끝날 때, 공주와 가장 가까운 사람이 여러분의 편지를 지니도록 하시기 바랍니다.</p>
        <p>여러분의 편지가 가장 먼저 아네트 공주에게 닿도록 말입니다.</p>
        <footer class="space-top">
          <button id="closeRules" class="secondary">닫기</button>
        </footer>
      </article>
    </div>
  </main>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const roomInput = document.getElementById('roomId');
    const nameInput = document.getElementById('name');
    const joinBtn = document.getElementById('join');
    const startBtn = document.getElementById('start');
    const consoleLogEl = document.getElementById('consoleLog');
    const playersEl = document.getElementById('players');
    const handEl = document.getElementById('hand');
    const requirementsEl = document.getElementById('requirements');
    const playActionBtn = document.getElementById('playAction');
    const actionHintEl = document.getElementById('actionHint');
    const discardEl = document.getElementById('discard');
    const deckInfoEl = document.getElementById('deckInfo');
    const stateEl = document.getElementById('state');
    const roomSections = document.querySelectorAll('[data-requires-room]');
    const startedSections = document.querySelectorAll('[data-requires-start]');
    const rulesModal = document.getElementById('rulesModal');
    const showRulesBtn = document.getElementById('showRules');
    const closeRulesBtn = document.getElementById('closeRules');
    const CARD_LABELS = {
      Guard: '경비병',
      Priest: '사제',
      Baron: '남작',
      Handmaid: '시녀',
      Prince: '왕자',
      King: '왕',
      Countess: '백작부인',
      Princess: '공주',
    };
    const labelCard = (name) => CARD_LABELS[name] || name;

    const showRoomUI = (show) => {
      roomSections.forEach((el) => el.classList.toggle('hidden', !show));
    };

    const showStartedUI = (show) => {
      startedSections.forEach((el) => el.classList.toggle('hidden', !show));
    };

    showRoomUI(false);
    showStartedUI(false);

    let currentRoom = '';
    let latestLog = [];
    let currentActions = [];
    let selectedActionIndex = null;

    const renderConsole = (log = latestLog) => {
      const lines = Array.isArray(log) ? log : [];
      consoleLogEl.textContent = lines.length
        ? lines.slice(-24).join('\n')
        : '아직 메시지가 없습니다. 게임을 시작하세요!';
    };

    const flashMessage = (msg) => {
      if (!msg) return;
      renderConsole([msg, ...(latestLog || [])]);
    };

    joinBtn.onclick = () => {
      if (currentRoom) {
        flashMessage('이미 방에 입장해 있습니다.');
        return;
      }
      const roomId = roomInput.value.trim() || 'lobby-1';
      currentRoom = roomId;
      socket.emit('join-room', { roomId, name: nameInput.value.trim() });
    };

    startBtn.onclick = () => {
      if (!currentRoom) {
        flashMessage('먼저 방에 입장하세요.');
        return;
      }
      socket.emit('start-game', currentRoom);
    };

    socket.on('state', (state) => {
      showRoomUI(true);
      showStartedUI(Boolean(state.started));
      latestLog = state.log || [];
      stateEl.textContent = JSON.stringify(state, null, 2);
      renderPlayers(state);
      renderActions(state);
      renderDiscard(state);
      deckInfoEl.textContent = `덱: ${state.deckCount}장 남음`;
      renderConsole();
    });

    socket.on('error-message', (msg) => {
      flashMessage(msg);
      if (!currentRoom) {
        showRoomUI(false);
        showStartedUI(false);
      }
    });

    showRulesBtn.onclick = () => rulesModal.classList.remove('hidden');
    closeRulesBtn.onclick = () => rulesModal.classList.add('hidden');
    rulesModal.onclick = (e) => {
      if (e.target === rulesModal) rulesModal.classList.add('hidden');
    };

    function renderPlayers(state) {
      playersEl.innerHTML = '';
      state.players.forEach((p) => {
        const chip = document.createElement('span');
        const flags = [
          p.isCurrent ? '★' : '',
          p.protected ? '보호' : '',
          p.eliminated ? '탈락' : '',
        ]
          .filter(Boolean)
          .join(' ');
        chip.textContent = `${p.name} ${flags ? ' [' + flags + ']' : ''}`;
        playersEl.appendChild(chip);
      });
    }

    function renderActions(state) {
      handEl.innerHTML = '';
      requirementsEl.innerHTML = '';
      actionHintEl.textContent = '';
      currentActions = state.actions || [];

      if (!state.started || !state.you) {
        handEl.textContent = '아직 패가 없습니다. 게임을 시작하세요!';
        playActionBtn.disabled = true;
        return;
      }

      if (selectedActionIndex === null || selectedActionIndex >= currentActions.length) {
        selectedActionIndex = currentActions.length ? 0 : null;
      }

      if (!currentActions.length) {
        handEl.textContent =
          state.currentPlayer === state.you.id
            ? '선택할 수 있는 행동이 없습니다.'
            : '다른 플레이어의 차례입니다.';
        playActionBtn.disabled = true;
        return;
      }

      currentActions.forEach((action, idx) => {
        const btn = document.createElement('button');
        btn.textContent = action.label;
        btn.type = 'button';
        if (action.disabledReason) {
          btn.disabled = true;
          btn.title = action.disabledReason;
        }
        if (idx === selectedActionIndex) btn.classList.add('contrast');
        btn.onclick = () => {
          if (action.disabledReason) return;
          selectedActionIndex = idx;
          renderActions(state);
        };
        handEl.appendChild(btn);
      });

      renderRequirements();
    }

    // 현재 선택된 행동에 필요한 입력 UI를 만들고 제출/검증 로직을 연결한다.
    function renderRequirements() {
      requirementsEl.innerHTML = '';
      actionHintEl.textContent = '';
      const action = currentActions[selectedActionIndex];
      if (!action) {
        playActionBtn.disabled = true;
        return;
      }

      const inputs = {};
      const targetReq = action.requires?.find((r) => r.type === 'target');
      const guessReq = action.requires?.find((r) => r.type === 'guess');

      action.requires?.forEach((req) => {
        if (req.type === 'target') {
          const label = document.createElement('label');
          label.textContent = req.label || '대상';
          const select = document.createElement('select');
          select.dataset.field = 'targetId';
          const empty = document.createElement('option');
          empty.value = '';
          empty.textContent = '선택하세요';
          select.appendChild(empty);
          req.options?.forEach((opt) => {
            const option = document.createElement('option');
            option.value = opt.id;
            option.textContent = opt.label;
            select.appendChild(option);
          });
          label.appendChild(select);
          requirementsEl.appendChild(label);
          inputs.targetId = select;
        } else if (req.type === 'guess') {
          const label = document.createElement('label');
          label.textContent = req.label || '추측';
          const input = document.createElement('input');
          input.type = 'number';
          if (req.min) input.min = req.min;
          if (req.max) input.max = req.max;
          input.dataset.field = 'guess';
          label.appendChild(input);
          requirementsEl.appendChild(label);
          inputs.guess = input;
        }
      });

      playActionBtn.onclick = () => {
        if (action.disabledReason) return;
        const payload = { roomId: currentRoom, cardIndex: action.cardIndex };
        let invalid = '';

        if (inputs.targetId) {
          const val = inputs.targetId.value;
          if (!val) {
            if (!targetReq?.optional) invalid = '대상을 선택하세요.';
          } else payload.targetId = val;
        }

        if (!invalid && inputs.guess) {
          const val = Number(inputs.guess.value);
          if (Number.isNaN(val)) invalid = '추측 숫자를 입력하세요.';
          else if (guessReq?.min && val < guessReq.min) invalid = '숫자가 너무 작습니다.';
          else if (guessReq?.max && val > guessReq.max) invalid = '숫자가 너무 큽니다.';
          else if ((guessReq?.exclude || []).includes(val)) invalid = '해당 숫자는 선택할 수 없습니다.';
          else payload.guess = val;
        }

        if (invalid) {
          actionHintEl.textContent = invalid;
          return;
        }

        socket.emit('play-card', payload);
      };

      playActionBtn.disabled = Boolean(action.disabledReason);
      actionHintEl.textContent = action.disabledReason || '';
    }

    function renderDiscard(state) {
      const nameById = Object.fromEntries(state.players.map((p) => [p.id, p.name]));
      discardEl.innerHTML = state.discard
        .map((c) => {
          const owner = c.by || '플레이어';
          const target = c.target ? ` → ${nameById[c.target] || c.target}` : '';
          return `${owner}님이 ${labelCard(c.name)}를 사용했습니다${target}`;
        })
        .join(' | ');
    }
  </script>
</body>
</html>
